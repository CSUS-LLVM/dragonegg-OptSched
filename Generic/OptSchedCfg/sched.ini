# Use optimal scheduling
# YES
# NO
# HOT_ONLY: Only use scheduler with hot functions.
USE_OPT_SCHED YES

# Print spill counts
# Same options as use optimal scheduling.
PRINT_SPILL_COUNTS YES

# A time limit for the whole region (basic block) in milliseconds. Defaults to no limit.
# Interpretation depends on the TIMEOUT_PER setting
REGION_TIMEOUT 0

# A time limit for each schedule length in milliseconds. Defaults to no limit.
# Interpretation depends on the TIMEOUT_PER setting
LENGTH_TIMEOUT 0

# The heuristic used for the list scheduler. Valid values are:
# CP: critical path.
# LUC: last use count
# UC: use count
# NID: node ID
# ISO: file scheduling order: scheduling order of the input instruction stream
# Now, that the optimal scheduler is integrated into the LLVM compiler,
# ISO means using the schedule generated by the LLVM heuristic scheduler
# specified by the LLVM_SCHEDULER opion
#HEURISTIC LUC_CP_NID
HEURISTIC NID

# The heuristic used for the enumerator. Same valid values as HEURISTIC.
ENUM_HEURISTIC LUC_CP_NID

# Whether to use ACO instead of the list scheduler.
USE_ACO NO

# The importance of the heuristic in ACO. ACO uses (1/heuristic)^importance, so
# importance of 0 means don't use the heuristic.
HEURISTIC_IMPORTANCE 1

# The spill cost function to be used. Valid values are:
# PEAK: peak excess reg pressure
# PRP: peak reg pressure
# SUM: sum of excess reg pressures across the block
# PEAK_PLUS_AVG: peak excess reg pressure plus the avg reg pressure across the block
# SLIL: sum of live interval lengths for each block
# SPILLS: number of spills after running a register allocator (doesn't work with enumerator)
SPILL_COST_FUNCTION SLIL

# Precision of latency info:
# PRECISE: use precise latencies from the machine_model.cfg file
# ROUGH: use the rough latencies assigned by the LLVM Compiler
# UNITY: set all latencies to unity
LATENCY_PRECISION UNITY

# The weight of the spill cost in the objective function. This factor
# defines the importance of spill cost relative to schedule length. A good
# value for this factor should be found experimentally, but is is expected
# to be large on architectures with hardware scheduling like x86 (thus
# making spill cost minimization the primary objective) and smaller on
# architectures with in-order execution like SPARC (thus making scheduling
# the primary objective).
SPILL_COST_FACTOR 100

# How to interpret the timeout value? Valid options:
# INSTR : multiply the time limits in the above fields by the number of
# instructions in the block
# BLOCK : use the time limits in the above fields as is
TIMEOUT_PER INSTR

# (Chris) If using the SLIL cost function, enabling this option
# will force the B&B scheduler to skip DAGs with zero PERP.
FILTER_BY_PERP NO

# (Chris) This setting chooses which blocks to keep and which blocks to discard.
# The scheduler will fall back to LLVM if the block is discarded.
# Valid options:
#   ALL: always take the block
#   IMPROVED: only take improved blocks
#   OPTIMAL: only take optimal blocks
#   IMPROVED_OR_OPTIMAL: only take improved or optimal blocks
#   ZERO_COST: only take zero-cost blocks
BLOCKS_TO_KEEP ALL

# (Chris) Override USE_OPT_SCHED to apply to specific regions.
# When SCHEDULE_SPECIFIC_REGIONS is set to YES, the scheduler
# will only schedule the regions specified by
# REGIONS_TO_SCHEDULE, which is a comma-separated list of
# scheduling regions
SCHEDULE_SPECIFIC_REGIONS NO
REGIONS_TO_SCHEDULE compute_connection_distances:2

# Whether to use suffix concatenation. Disabled automatically if
# history domination is disabled
ENABLE_SUFFIX_CONCATENATION NO

# Whether to apply the node superiority graph transformation.
STATIC_NODE_SUPERIORITY NO

# Whether to apply node superiority in multiple passes.
MULTI_PASS_NODE_SUPERIORITY NO

# Whether to apply relaxed pruning. Defaults to YES.
APPLY_RELAXED_PRUNING YES

# Whether to apply spill-cost pruning. Defaults to YES.
APPLY_SPILL_COST_PRUNING YES

# Whether to apply history-based domination. Defaults to YES.
APPLY_HISTORY_DOMINATION YES

# Add registers that are defined but not used and are not in the
# live-out set from LLVM.
ADD_DEFINED_AND_NOT_USED_REGS YES

# Add registers that are used but not defined.
ADD_USED_AND_NOT_DEFINED_REGS YES

# Add registers that are live-out but not defined.
ADD_LIVE_OUT_AND_NOT_DEFINED_REGS YES

# Use simple register types. In the machine scheduler this means
# use the first PSet associated with a RegUnit.
USE_SIMPLE_REGISTER_TYPES NO

# Should we simulate register allocation to the evaluate the effect
# of scheduling decisions on estimated spill count.
# BEST: Only simulate RA with the best (lowest cost) schedule.
# LIST: Only simulate RA with the list schedule.
# BOTH: Simulate RA using the best schedule and the list schedule.
# TAKE_SCHED_WITH_LEAST_SPILLS: Simulate RA using the best schedule and the list schedule, and
# take the schedule that generates the least spills.
# NO: Do not simulate register allocation.
SIMULATE_REGISTER_ALLOCATION BEST

# Should we ignore ilp and only schedule for register pressure
SCHEDULE_FOR_RP_ONLY NO

# Whether to enumerate schedules containing stalls (no-op instructions).
# In certain cases, such as having unpipelined instructions, this may
# result in a better schedule. Defaults to YES.
ENUMERATE_STALLS NO

#The algorithm to use for determining the lower bound. Valid values are:
# RJ: Rim and Jain's algorithm.
# LC: Langevin and Cerny's algorithm.
# Defaults to LC.
LB_ALG LC

# Whether LLVM mutations should be applyed to the DAG
LLVM_MUTATIONS NO

# Whether to verify that calculated schedules are optimal. Defaults to NO.
VERIFY_SCHEDULE YES

# Whether to apply dynamic node superiority. Defaults to NO.
DYNAMIC_NODE_SUPERIORITY NO

# Whether to compare calculated results with the input file. Defaults to NO.
COMPARE_RESULTS NO

# Whether to print statistics about timeouts in the summary. Defaults to NO.
PRINT_TIMEOUTS NO

# An option to treat data dependencies of type ORDER as data dependencies
TREAT_ORDER_DEPS_AS_DATA_DEPS NO

# Check spill cost sum at all points in the block for the enumerator's best
# schedule and the heuristic schedule. If the latter sum is smaller, take
# the heuristic schedule instead (if the heuristic sched length is not larger).
# This can happen, when the SPILL_COST_FUNCTION is not set to SUM.
CHECK_SPILL_COST_SUM NO

# Check the total number of conflicts among live ranges for the enumerator's best
# schedule and the heuristic schedule. If the latter is smaller, take
# the heuristic schedule instead (if the heuristic sched length is not larger).
# Check conflicts
CHECK_CONFLICTS NO

# Force CopyFromReg instrs to be scheduled before all other instrs in the block
FIX_LIVEIN NO

# Force CopyToReg instrs to be scheduled after all other instrs in the block
FIX_LIVEOUT NO

# Bypass the machine CSE pass
BYPASS_MACHINE_CSE NO

# Bypass the machine LICM pass
BYPASS_MACHINE_LICM NO

# Which dags to write to the output file. Valid values are:
# ALL: All DAGs are written.
# OPT: Only optimal DAGs are written.
# IMP: Only improved DAGs (whether optimal or not) are written.
# HARD: Only hard DAGs are written.
# NONE: No DAGs are written.
OUTPUT_DAGS NONE

# The maximum spill cost to process. Any block whose heuristic spill cost
# is larger than this value will not be processed by the optimal scheduler
# If this field is set to 0, there will be no limit; all blocks will be
# processed by the optimal scheduler
MAX_SPILL_COST 0

# The minimum number of instructions that a block can contain to be
# processed by the optimal scheduler
MIN_DAG_SIZE 0

# The maximum number of instructions allowed in an output dependency graph.
MAX_OUTPUT_DAG_SIZE 10

# The maximum number of instructions that a block can contain to be
# processed by the optimal scheduler
MAX_DAG_SIZE 10000

# The maximum DAG size to be scheduled using precise latency information.
# DAGs with larger sizes than this value will be processed using rough
# latencies
MAX_DAG_SIZE_FOR_PRECISE_LATENCY 10000

# The filename of the output DAG file. Can either be a path or one of the
# two special values: "NONE", meaning no output file is used, or "AUTO",
# meaning it has the same name as the input file but with ".out" added.
OUTPUT_FILE ../output/test_out.dag

# The number of bits in the hash table used in history-based domination.
HIST_TABLE_HASH_BITS 16

# The integer used to seed the random number generator. Read from settings.
RANDOM_SEED 56577

# The period of the periodic log, in milliseconds. The periodic log prints info
# about current enumeration status every period.
LOG_PERIOD 1800000

# The minimum block weight needed to deem a block worth processing. Blocks
# with lower weights are skipped.
MIN_DAG_WEIGHT 0

# The maximum number of blocks to process before stopping. Defaults to all.
MAX_BLOCKS_TO_PROCESS 10000

# Whether to use the lower/upper bounds defined in the input file. Defaults to
# YES.
USE_FILE_BOUNDS NO

# Whether to use the latencies listed in the DAG file for each edge as opposed
# to the instruction latencies defined in the machine model. These may have
# different values as the compiler may adjust the latencies in certain cases.
# Defaults to YES.
USE_FILE_LATENCIES NO
